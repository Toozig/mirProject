# -*- coding: utf-8 -*-
"""gene_mir_network_analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D0zpaRI_KUnfoygXWaeopLsQEmrJw7MX
"""

import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
from sklearn import neighbors, linear_model, metrics, ensemble, model_selection

# %%

MIR_FAMILY = 'miR family'
GENE_SYMBOL = 'Gene Symbol'
MIR_ID = 'MiRBase ID'
HUMAN_TOXONOMY_ID = 9606
CNV = 2
BOTH = 3
WT = 1


def generate_family_to_gene_table(geneDF=False):
    """
    This function connect between  mir family and gen, output example - "gene_to_mir_family_CCLE.pick"
    No need to use it, use the gene_to_mir_family_CCLE.pick file
    """
    gene_targets = get_ts_gene_target() if geneDF is False else geneDF
    gene_set = set(gene_targets[GENE_SYMBOL].values.tolist())
    gene_set = gene_set
    family_set = list(set(gene_targets['miR Family'].values.tolist()))
    res = pd.DataFrame(index=family_set)
    for gene in gene_set:
        mini_gene = gene_targets[gene_targets[GENE_SYMBOL] == gene]
        # family_list = gene_targets['miR Family'][gene_targets[GENE_SYMBOL].isin([gene_targets])]
        res[gene] = res.index.isin(mini_gene['miR Family'])
    return res


def get_ts_gene_target(pct=0):
    """
    Filter the data from TargetScan to human only and can be filttered according to pct (how good is the connection prediciton)
    """
    gene_targets = pd.read_csv(
        "DB/Predicted_Targets_Info.default_predictions.txt", delimiter='\t')
    gene_targets = gene_targets[
        gene_targets['Species ID'] == HUMAN_TOXONOMY_ID]
    gene_targets = gene_targets[gene_targets['PCT'] >= pct]
    return gene_targets


def tomour_suppressor_gene():
    """

    """
    ts_gene = get_ts_gene_target()
    tomour_list = pd.read_csv("DB/Human_TSGs.txt", sep='\t')
    return ts_gene[ts_gene[GENE_SYMBOL].isin(tomour_list["GeneSymbol"])]


def add_family_label(cnv_map: pd.DataFrame):
    """
    Add the family label to each mir
    no need to use, internal use
    """
    family_to_mir = pd.read_csv("DB/miR_Family_filtered.csv")
    cnv_map[MIR_FAMILY] = np.nan
    family_set = set(family_to_mir[MIR_FAMILY].values)
    for family in family_set:
        mir_list = family_to_mir[MIR_ID][
            family_to_mir[MIR_FAMILY] == family].values
        mini_cnv = cnv_map.iloc[cnv_map['miRNA'].isin(mir_list).values]
        cnv_map[MIR_FAMILY][
            cnv_map['miRNA'].isin(mini_cnv['miRNA'].values)] = family

    family_label = cnv_map[MIR_FAMILY]
    filter_cnv_map = cnv_map.drop(MIR_FAMILY, axis=1)

    return filter_cnv_map, family_label


def mir_bool_gene(genedf: pd.DataFrame, family_label, all_mir):
    res = pd.DataFrame()
    for idx, mir in all_mir.iterrows():
        res[mir] = genedf.iloc[genedf.index == family_label.iloc[idx]].T

    return res.T


def create_profiling2(samples_data: pd.DataFrame,
                      gene_mir_df: pd.DataFrame, to_sum=True):
    """
    generates the network vector to the samples according to the gene to mir DF
    """

    # filter to gene with mir interaction

    if to_sum:
        res = np.sum(gene_mir_df.to_numpy().reshape(
            (gene_mir_df.shape[0], 1, gene_mir_df.shape[1])) *
                     samples_data.to_numpy()[..., np.newaxis], axis=0)
        return pd.DataFrame(res.T, columns=samples_data.columns,
                            index=gene_mir_df.columns)
        pass
    res = (gene_mir_df.to_numpy().reshape(
        (gene_mir_df.shape[0], 1, gene_mir_df.shape[1])) * samples_data.to_numpy()[
               ..., np.newaxis]).T

    alternative_res  = gene_mir_df.to_numpy().reshape(
        (1, gene_mir_df.shape[0], gene_mir_df.shape[1])) * samples_data.to_numpy().T[
                           ..., np.newaxis]

    headers =(gene_mir_df.columns + ' / ').to_numpy().astype(str)[np.newaxis, ...] \
             + ( ' ' + gene_mir_df.index).to_numpy()[..., np.newaxis]


    nu = pd.DataFrame(res.reshape((-1,res.shape[1])).T) - pd.DataFrame(alternative_res.reshape(((alternative_res.shape[0], -1))), columns=headers.flatten(), index=samples_data.columns).to_numpy()
    first_net = (gene_mir_df.T * samples_data[samples_data.columns[0]]).T

    ret = pd.DataFrame(alternative_res.reshape(((alternative_res.shape[0], -1))), columns=headers.flatten(), index=samples_data.columns)
    # pd.DataFrame(res.reshape((-1,res.shape[1])).T).to_csv("good_result.csv")
    # first_net.to_csv("first_net.csv")
    res1 = pd.DataFrame(res.reshape((-1,res.shape[1])).T)
    return ret


def gene_tissue_how_many_mirs(cnv_df: pd.DataFrame, gene_name_list=False,
                              to_sum=True):
    # gets the data from targetScan
    gene_list = get_ts_gene_target()
    gene_list = gene_list[gene_list[GENE_SYMBOL].isin(
        gene_name_list)] if gene_name_list is not False else gene_list
    gene_list = generate_family_to_gene_table(gene_list)
    # add family label to each mir
    edited_cnv_df, family_label = add_family_label(cnv_df)
    family_label = family_label[family_label.isin(gene_list.index)]
    mir_name = edited_cnv_df['miRNA']
    edited_cnv_df = edited_cnv_df.iloc[
        family_label.index._values].reset_index(drop=True)
    mir_name = mir_name[family_label.index._values].reset_index(drop=True)
    family_label = family_label.reset_index(drop=True)
    # creates the amount of each gene according to the WT
    normalize_factor = edited_cnv_df['Initial CN']
    edited_cnv_df = edited_cnv_df.drop(['Initial CN', 'miRNA'], axis=1)
    gene_list = mir_bool_gene(gene_list, family_label, pd.DataFrame(mir_name))
    edited_cnv_df = pd.DataFrame(edited_cnv_df.to_numpy() / (
                normalize_factor.to_numpy()[..., np.newaxis] * 2),
                                 columns=edited_cnv_df.columns, index=gene_list.index)
    return create_profiling2(edited_cnv_df, gene_list, to_sum)


# takes each cancer type file and performs the network analysis on it
def classification_from_network():
    df_list = []
    index_label_dic = {}
    ts_gene = tomour_suppressor_gene()
    directory = os.fsencode("DB/tcga")
    i = 0
    for file in os.listdir(directory):
        filename = os.fsdecode(file)
        tcga = pd.read_csv("DB/tcga/" + filename)
        result = gene_tissue_how_many_mirs(tcga, ts_gene[GENE_SYMBOL].values,
                                           False)
        df_list.append(result)
        index_label_dic[i] = filename.replace(".csv", "")
        print(filename)
        i += 1
    lables = []
    for i in range(len(df_list)):
        lables += [index_label_dic[i]] * df_list[i].shape[0]
    return pd.concat(df_list), lables




# %%
def random_forest(X_train, y_train, X_test, y_test, labels, trees=361, to_print=False):
    rf = ensemble.RandomForestClassifier(n_estimators=trees, random_state=42, )
    rf.fit(X_train, y_train)
    score = rf.score(X_test, y_test)
    print("Train score: %s" %rf.score(X_train, y_train))
    print("Test score: %s" %rf.score(X_test, y_test))
    if to_print:
        print(score)
        metrics.plot_confusion_matrix(rf, X_test, y_test,
                                      labels=None,
                                      normalize='true',
                                      display_labels=labels,
                                      values_format='.2f',
                                      cmap=plt.cm.Purples,
                                      xticks_rotation='vertical')

        plt.title("Multi Class Random Forest Confusion Matrix (n=361)")
        plt.show()
    return rf, score


def get_RF_model(data, lables,trees=361, var_threshhold=0.011):
    # filter the data by variance
    # variance = data.var(axis=0)
    # filtered = data.loc[:, variance > var_threshhold]
    # filtered = data[:, variance > var_threshhold]
    train_data_genes, test_data_genes, train_labels_genes, test_labels_genes = \
        model_selection.train_test_split(data, lables, test_size=0.2, stratify=lables)
    model, score = random_forest(train_data_genes, train_labels_genes,
                                 test_data_genes, test_labels_genes, set(lables),trees=trees, to_print=True)
    return model, score
